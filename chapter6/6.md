# 第六章
[DC06PE01已知完全二叉树采用顺序存储结构，求编号i和j的两个结点的最近公共祖先结点的编号](#DC06PE01-已知完全二叉树采用顺序存储结构求编号i和j的两个结点的最近公共祖先结点的编号)  
[DC06PE02 对于顺序结构的完全二叉树，判别结点v是否为结点u的子孙](#DC06PE02-对于顺序结构的完全二叉树判别结点v是否为结点u的子孙)  
[DC06PE06 判别两棵二叉树是否相似](#DC06PE06-判别两棵二叉树是否相似)  
[DC06PE11 编写递归算法，求对二叉树T先序遍历时第k个访问的结点的值](#DC06PE11-编写递归算法求对二叉树T先序遍历时第k个访问的结点的值)  
[DC06PE12 编写递归算法，计算二叉树T中叶子结点的数目](#DC06PE12-编写递归算法，计算二叉树T中叶子结点的数目)  
[DC06PE21 利用栈及其基本操作，编写二叉树的非递归的先序遍历算法](#DC06PE21-利用栈及其基本操作编写二叉树的非递归的先序遍历算法)  
[DC06PE23 中序遍历二叉树，输出不小于某关键字的结点值](#DC06PE23-中序遍历二叉树输出不小于某关键字的结点值)  
[DC06PE27 先序遍历二叉树，输出不小于某关键字的结点值](#DC06PE27-先序遍历二叉树输出不小于某关键字的结点值)  
[DC06PE29 后序遍历二叉树，输出不小于某关键字的结点值](#DC06PE29后序遍历二叉树输出不小于某关键字的结点值)  
[DC06PE30 判别给定两棵二叉树是否同构](#DC06PE30-判别给定两棵二叉树是否同构)  
[DC06PE31 利用栈的基本操作，写出先序遍历的非递归形式的算法](#DC06PE31-利用栈的基本操作写出先序遍历的非递归形式的算法)  
[DC06PE32 利用栈的基本操作，写出后序遍历的非递归算法](#DC06PE32-利用栈的基本操作写出后序遍历的非递归算法)  
[DC06PE33 编写递归算法，将二叉树中所有结点的左、右子树相互交换](#DC06PE33-编写递归算法将二叉树中所有结点的左右子树相互交换)  
[DC06PE34 不使用栈，写出三叉链表的后序遍历的非递归算法](#DC06PE34-不使用栈写出三叉链表的后序遍历的非递归算法)  
[DC06PE35 不使用栈，写出三叉链表的中序遍历的非递归算法](#DC06PE35-不使用栈写出三叉链表的中序遍历的非递归算法)  
[DC06PE36 求以二叉链表存储的完全二叉树的最后一层的最后一个结点](#DC06PE36-求以二叉链表存储的完全二叉树的最后一层的最后一个结点)  
[DC06PE37 编写递归算法：求当前结点的双亲结点](#DC06PE37-编写递归算法求当前结点的双亲结点)  
[DC06PE40 编写递归算法：判断某两个结点是否为兄弟](#DC06PE40-编写递归算法判断某两个结点是否为兄弟)  
[DC06PE43 编写复制一棵二叉树的递归算法](#DC06PE43-编写复制一棵二叉树的递归算法)  
[DC06PE44 编写递归算法，求二叉树中以元素值为x的结点为根的子树的深度](#DC06PE44-编写递归算法求二叉树中以元素值为x的结点为根的子树的深度)  
[DC06PE45 编写递归算法，对于二叉树中每一个元素值为x的结点，删去以它为根的子树，并释放相应的空间](#DC06PE45-编写递归算法对于二叉树中每一个元素值为x的结点删去以它为根的子树并释放相应的空间)  
[DC06PE46 复制一棵二叉树（非递归，利用队列）](#DC06PE46-复制一棵二叉树非递归利用队列)  
[DC06PE47 利用队列的基本操作，编写按层次顺序(同一层自左至右)遍历二叉树的算法](#DC06PE47-利用队列的基本操作编写按层次顺序同一层自左至右遍历二叉树的算法)  
[DC06PE48 已知二叉树中的两个结点，求距离它们最近的共同祖先](#DC06PE48-已知二叉树中的两个结点求距离它们最近的共同祖先)  
[DC06PE49 编写算法判别给定二叉树是否为完全二叉树](#DC06PE49-编写算法判别给定二叉树是否为完全二叉树)  
[DC06PE50 判别两棵二叉树是否相等](#DC06PE50-判别两棵二叉树是否相等)  
[DC06PE51 求二叉树中度为1的结点数目](#DC06PE51-求二叉树中度为1的结点数目)  
[DC06PE52 求二叉树的分支结点总数](#DC06PE52-求二叉树的分支结点总数)  
[DC06PE53 按层次遍历方式计算二叉树的结点个数](#DC06PE53-按层次遍历方式计算二叉树的结点个数)  
[DC06PE54 对一棵二叉树，将它的所有没有左孩子但有右孩子的结点，将其右孩子改变为左孩子](#DC06PE54-对一棵二叉树将它的所有没有左孩子但有右孩子的结点将其右孩子改变为左孩子)  
[DC06PE55 求二叉树的宽度](#DC06PE55求二叉树的宽度)  
[DC06PE56 编写递归算法，查找求二叉树T中是否存在元素值为x的结点](#DC06PE56-编写递归算法查找求二叉树T中是否存在元素值为x的结点)  
[DC06PE57 计算二叉树中值为x的结点所在的层次](#DC06PE57-计算二叉树中值为x的结点所在的层次)  
[DC06PE58 求二叉树中以元素值为x的结点为根的子树的结点总数](#DC06PE58-求二叉树中以元素值为x的结点为根的子树的结点总数)  
[DC06PE59 求指定结点在二叉树中的层次](#DC06PE59-求指定结点在二叉树中的层次)  
[DC06PE60 判别一棵二叉树是否为正则二叉树](#DC06PE60判别一棵二叉树是否为正则二叉树)  
[DC06PE61 判别一棵二叉树是否为小根二叉树](#DC06PE61-判别一棵二叉树是否为小根二叉树)  
[DC06PE62 利用队列，非递归求解二叉树的宽度](#DC06PE62-利用队列非递归求解二叉树的宽度)  
[DC06PE65 试编写一个二叉排序树的判定算法](#DC06PE65-试编写一个二叉排序树的判定算法)  
[DC06PE66 从大到小输出给定二叉排序树中所有关键字不小于x的数据元素](#DC06PE66-从大到小输出给定二叉排序树中所有关键字不小于x的数据元素)  
[DC06PE67 在二叉查找树中插入一个元素](#DC06PE67-在二叉查找树中插入一个元素)  
[DC06PE68 求二叉树T中任意两个结点的最近共同祖先](#DC06PE68-求二叉树T中任意两个结点的最近共同祖先)  
[DC06PE69 将二叉树以字符串形式输出](#DC06PE69-将二叉树以字符串形式输出)  
[DC06PE75 求二叉排序树中第k小的结点的位置](#DC06PE75-求二叉排序树中第k小的结点的位置)  
[DC06PE77 求平衡树T的深度，并j记录每个结点平衡因子](#DC06PE77-求平衡树T的深度并j记录每个结点平衡因子)  
[DC06PE82 平衡二叉排序树的右平衡处理](#DC06PE82-平衡二叉排序树的右平衡处理)  

## DC06PE01 已知完全二叉树采用顺序存储结构，求编号i和j的两个结点的最近公共祖先结点的编号
```c
int commonAncestor(SqBiTree T, int i, int j) 
{  // Add your code here
  if (i>T.lastIndex||j>T.lastIndex||i<2||j<2) {
    return 0;
  }
  i/=2;
  j/=2;
  while (i!=j) {
    if (i>j) {
        i/=2;
    }
    if (j>i) {
        j/=2;
    }
  }
  return i;
}
```
## DC06PE02 对于顺序结构的完全二叉树，判别结点v是否为结点u的子孙
```c
Status is_Desendant(SqBiTree T, int u, int v)  
{  // Add your code here
   if (u<1||u>T.lastIndex||v<1||v>T.lastIndex||v<=u) {
    return FALSE;
   }
    while (v>u) {
        v/=2;
    }
    if (u==v) {
        return TRUE;
    }
    return FALSE;
}
```
## DC06PE06 判别两棵二叉树是否相似。
```c
Status Similar(BiTree T1, BiTree T2) 
{   // Add your code here
    if (T1==NULL||T2==NULL) {
        if (T1==NULL&&T2==NULL) {
            return TRUE;
        }
        return FALSE;
    }
    int r1=Similar(T1->lchild, T2->lchild);
    int r2=Similar(T1->rchild, T2->rchild);
    return r1&&r2;
}
```
## DC06PE11 编写递归算法，求对二叉树T先序遍历时第k个访问的结点的值。
```c
TElemType a(BiTree T, int &k){
    TElemType result ='#';
    if (T==NULL) {
        return result;
    }
    if (k==1) {
        return T->data;
    }
    k--;
    if (T->lchild!=NULL) {
        result=a(T->lchild,k);
    }
    if (T->rchild!=NULL && result == '#') {
        result=a(T->rchild,k);
    }
    return result;
}
TElemType PreOrderK(BiTree T, int k) 
{   // Add your code here
    return a(T,k);
}
```
## DC06PE12 编写递归算法，计算二叉树T中叶子结点的数目。
```c
int Leaves(BiTree T) 
{   // Add your code here
    if (T==NULL) {
        return 0;
    }
    if (T->lchild==NULL&&T->rchild==NULL) {
        return 1;
    }
    int reL=Leaves(T->lchild);
    int reR=Leaves(T->rchild);
    return reL+reR;
}
```
## DC06PE21 利用栈及其基本操作，编写二叉树的非递归的先序遍历算法。
```c
void PreOrder(BiTree T, Status (*visit)(TElemType))
{   // Add your code here
    Stack S;
    InitStack(S);
    BiTree p=T;

    while (StackEmpty(S)!=TRUE||p!=NULL) {
        while (p) {
            visit(p->data);
            Push(S,p);
            p=p->lchild;
        }
        if (!StackEmpty(S)) {
            Pop(S,p);
            p=p->rchild;
        }
    }
    return;
}
```
## DC06PE23 中序遍历二叉树，输出不小于某关键字的结点值
```c
void printNoLessThanKey_InOrder(BiTree T, TElemType k) 
{  // Add your code here
    if (T==NULL) {
        return;
    }
    printNoLessThanKey_InOrder(T->lchild, k);
    if (T->data>=k) {
        printKey(T->data);
    }
    printNoLessThanKey_InOrder(T->rchild, k);
    return;
}
```
## DC06PE27 先序遍历二叉树，输出不小于某关键字的结点值
```c
void printNoLessThanKey_PreOrder(BiTree T, TElemType k) 
{  // Add your code here
    if (T==NULL) {
        return;
    }
    
    if (T->data>=k) {
        printKey(T->data);
    }
    printNoLessThanKey_PreOrder(T->lchild, k);
    printNoLessThanKey_PreOrder(T->rchild, k);
    return;
}
```
## DC06PE29 后序遍历二叉树，输出不小于某关键字的结点值
```c
void printNoLessThanKey_PostOrder(BiTree T, TElemType k) 
{  // Add your code here
    if (T==NULL) {
        return;
    }
    printNoLessThanKey_PostOrder(T->lchild, k);
    printNoLessThanKey_PostOrder(T->rchild, k);
    if (T->data>=k) {
        printKey(T->data);
    }
    return;
}
```
## DC06PE30 判别给定两棵二叉树是否同构
```c
Status isIsomorphic(BiTree T1, BiTree T2)
{// Add your code here
    if (T1==NULL||T2==NULL) {
        if (T1==NULL&&T2==NULL) {
            return TRUE;
        }
        return FALSE;
    }
    if (T1->data==T2->data) {
        bool noSwap = isIsomorphic(T1->lchild,T2->lchild)&&isIsomorphic(T1->rchild,T2->rchild);
        bool swapped = isIsomorphic(T1->lchild,T2->rchild)&&isIsomorphic(T1->rchild,T2->lchild);
        return noSwap || swapped;
    }
    
    return FALSE;
}
```
## DC06PE31 利用栈的基本操作，写出先序遍历的非递归形式的算法
```c
void PreOrder(BiTree bt, void (*visit)(TElemType)) 
{  // Add your code here
    SqStack2 S;
    InitStack_Sq2(S);
    BiTree p = bt;
    while (p||!StackEmpty_Sq2(S)) {
        if (p) {
            visit(p->data);
            Push_Sq2(S,p);
            p = p->lchild;
        }else {
            Pop_Sq2(S,p);
            p=p->rchild;
        }
    }

}
```
## DC06PE32 利用栈的基本操作，写出后序遍历的非递归算法
```c
void PostOrder(BiTree bt, void (*visit)(TElemType))
/* 使用栈，非递归后序遍历二叉树bt，    */
/* 对每个结点的元素域data调用函数visit */
{    // Add your code here
    if(bt == NULL) 
      return;
    SqStack2 S;   
    InitStack_Sq2(S);    
    SElemType e;
    BiTree p = bt;
    
    e.ptr=p;
    e.tag=0;
    Push_Sq2(S,e);
    while(StackEmpty_Sq2(S)!=TRUE)
    {
        Pop_Sq2(S,e);
        if(e.tag==0)
        {    
            e.tag=1;
            Push_Sq2(S,e); 
            
            if(e.ptr->lchild!=NULL)
            {
                e.ptr=e.ptr->lchild;
                e.tag=0;
                Push_Sq2(S,e);
            }   
            continue;
        }
        if(e.tag==1)
        {
             e.tag=2;
             Push_Sq2(S,e); 
             
             if(e.ptr->rchild!=NULL)
             {
                e.ptr=e.ptr->rchild;
                e.tag=0;
                Push_Sq2(S,e);
             } 
             continue;
        }
        if(e.tag==2)
        {
             visit(e.ptr->data);        
        }    
    }
}
```
## DC06PE33 编写递归算法，将二叉树中所有结点的左、右子树相互交换。
```c
void ExchangeSubTree(BiTree &T)
{   // Add your code here
    BiTree temp;
    if (T==NULL) {
        return;
    }

    temp=T->rchild;
    T->rchild=T->lchild;
    T->lchild=temp;

    ExchangeSubTree(T->lchild);
    ExchangeSubTree(T->rchild);
}
```
## DC06PE34 不使用栈，写出三叉链表的后序遍历的非递归算法
```c
void PostOrder(TriTree bt, void (*visit)(TElemType))
/* 不使用栈，非递归后序遍历二叉树bt，  */
/* 对每个结点的元素域data调用函数visit */
{  // Add your code here
    TriTree p=bt;

    while (p!=NULL) {
        if (p->mark==0) {
            p->mark++;
            while (p->lchild!=NULL) {
                p=p->lchild;
                p->mark++;
            }
            continue;
        }//先递归到树的最左边
        if (p->mark==1) {
            p->mark++;
            if (p->rchild!=NULL) {
                p=p->rchild;
            }
            continue;
        }//当遇到已经遍历过的节点，往右遍历
        if (p->mark==2) {
            visit(p->data);
            p=p->parent;
        }
    }

}
```
## DC06PE35 不使用栈，写出三叉链表的中序遍历的非递归算法
```c
void InOrder(TriTree bt, void (*visit)(TElemType))
/* 不使用栈，非递归中序遍历二叉树bt， */
/* 对每个结点的元素域data调用函数visit */
{  
    TriTree p = bt;

    while (p != NULL) {
        if (p->mark == 0) {  // 第一次访问节点
            p->mark = 1;  // 标记为左子树已访问
            if (p->lchild != NULL) {
                p = p->lchild;  // 继续向左子树走
                continue;
            }
        }
        
        if (p->mark == 1) {  // 左子树已访问，访问当前节点
            visit(p->data);  // 访问当前节点
            p->mark = 2;  // 标记为当前节点已访问，准备访问右子树
            if (p->rchild != NULL) {
                p = p->rchild;  // 向右子树遍历
                continue;
            }
        }
        
        if (p->mark == 2) {  // 左右子树都已访问，回到父节点
            p = p->parent;  // 返回父节点继续遍历
        }
    }
}

```
## DC06PE36 求以二叉链表存储的完全二叉树的最后一层的最后一个结点
```c
#include "allinclude.h"
#include <queue>
BiTNode* getLastNode(BiTree T)
/* 求完全二叉树的最后一层的最后一个结点 */
{
    if (T == NULL) {
        return NULL;
    }
    
    // 使用队列进行层次遍历
    std::queue<BiTree> q;
    q.push(T);
    BiTree lastNode = NULL;

    while (!q.empty()) {
        lastNode = q.front(); // 当前节点
        q.pop();
        
        // 依次将左右子节点加入队列
        if (lastNode->lchild) {
            q.push(lastNode->lchild);
        }
        if (lastNode->rchild) {
            q.push(lastNode->rchild);
        }
    }

    // 最后的`lastNode`即为最后一个节点
    return lastNode;
}

```
## DC06PE37 编写递归算法：求当前结点的双亲结点。
```c
TElemType findParent(BiTree T, TElemType data, BiTNode* parent)
{   //Add your code here
    if (T==NULL||T->data==data) {
        return NULL;
    }
    if ((T->lchild!=NULL && T->lchild->data==data)||(T->rchild!=NULL && T->rchild->data==data)) {
        return T->data;
    }
    TElemType leftResult =findParent(T->lchild,data,NULL);
    if (leftResult!=NULL) {
        return leftResult;
    }
    return findParent(T->rchild,data,NULL);
}
```
## DC06PE40 编写递归算法：判断某两个结点是否为兄弟。
```c
Status isBrother(BiTree T, TElemType dx, TElemType dy)
{    // Add your code here
     if (T==NULL) {
          return FALSE;
     }
     if (T->lchild!=NULL && T->rchild!=NULL) {
          if (((T->lchild->data==dx && T->rchild->data==dy)||
          (T->rchild->data==dx && T->lchild->data==dy))) {
               return TRUE;
          }
     }
     if (isBrother(T->lchild,dx,dy)) {
          return TRUE;
     }
     return isBrother(T->rchild,dx,dy);  //Temporary code. Modify it if necessary.
}
```
## DC06PE43 编写复制一棵二叉树的递归算法。
```c
void CopyBiTree(BiTree T, BiTree &TT)
{   // Add your code here
    if (T==NULL) {
        TT=NULL;
        return;
    }
    TT=(BiTree)malloc(sizeof(BiTNode));
    TT->data=T->data;
    TT->lchild=NULL;
    TT->rchild=NULL;
    
    CopyBiTree(T->lchild,TT->lchild);
    CopyBiTree(T->rchild,TT->rchild);
}
```
## DC06PE44 编写递归算法，求二叉树中以元素值为x的结点为根的子树的深度
```c
int depth(BiTree T){
    if (T==NULL) {
        return 0;
    }
    int left=depth(T->lchild);
    int right=depth(T->rchild);
    return 1+(left>right?left:right);
}//计算深度
int Depthx(BiTree T, TElemType x)
{  // Add your code here
    if (T==NULL) {
        return 0;
    }

    if (T->data==x) {
        return depth(T);
    } 
    int leftDepth = Depthx(T->lchild,x);
    int rightDepth = Depthx(T->rchild,x);
    return leftDepth>0?leftDepth:rightDepth;
}//查找是否有x
```
## DC06PE45 编写递归算法，对于二叉树中每一个元素值为x的结点，删去以它为根的子树，并释放相应的空间
```c
void delete2(BiTree &bt){
    if (bt==NULL) {
        return;
    }
    delete2(bt->lchild);
    delete2(bt->rchild);

    free(bt);
    bt==NULL;
}
void ReleaseX(BiTree &bt, char x)
{  // Add your code here
    if (bt==NULL) {
        return;
    }
    if (bt->data==x) {
        delete2(bt);
        bt=NULL;
        return;
    }
    ReleaseX(bt->lchild,x);
    ReleaseX(bt->rchild,x);
}
```
## DC06PE46 复制一棵二叉树（非递归，利用队列）
```c
void CopyBiTree(BiTree T, BiTree &TT)
{  // Add your code here
    if (T==NULL) {
        TT=NULL;
        return;
    }
    LQueue Q;
    InitQueue_LQ(Q);

    TT=(BiTree)malloc(sizeof(BiTree));
    TT->data=T->data;
    TT->lchild=TT->rchild=NULL;

    EnQueue_LQ(Q,T);
    EnQueue_LQ(Q,TT);

    while (!QueueEmpty_LQ(Q)) {
        BiTree originalNode,copyNode;
        DeQueue_LQ(Q,originalNode);
        DeQueue_LQ(Q,copyNode);

        if (originalNode->lchild!=NULL) {
            copyNode->lchild=(BiTree)malloc(sizeof(BiTNode));
            copyNode->lchild->data=originalNode->lchild->data;
            copyNode->lchild->lchild=copyNode->lchild->rchild=NULL;

            EnQueue_LQ(Q,originalNode->lchild);
            EnQueue_LQ(Q,copyNode->lchild);
        }
        if (originalNode->rchild!=NULL) {
            copyNode->rchild=(BiTree)malloc(sizeof(BiTNode));
            copyNode->rchild->data=originalNode->rchild->data;
            copyNode->rchild->lchild=copyNode->rchild->rchild=NULL;

            EnQueue_LQ(Q,originalNode->rchild);
            EnQueue_LQ(Q,copyNode->rchild);
        }
    }
}
```
## DC06PE47 利用队列的基本操作，编写按层次顺序(同一层自左至右)遍历二叉树的算法
```c
void LevelOrder(BiTree bt, char *ss)
{  // Add your code here
    if(bt == NULL)
    return;
    BiTree p =bt;
    char sp[2]={0};
    LQueue Q;
    InitQueue_LQ(Q);
  
    EnQueue_LQ(Q,p);
    while (!QueueEmpty_LQ(Q)) {
        DeQueue_LQ(Q,p);
        sprintf(sp,"%c",p->data);
        strcat(ss,sp);

        if (p->lchild!=NULL) {
            EnQueue_LQ(Q,p->lchild);
        }
        if (p->rchild!=NULL) {
            EnQueue_LQ(Q,p->rchild);
        }
    }
}
```
## DC06PE48 已知二叉树中的两个结点，求距离它们最近的共同祖先
```c
bool FindPath(BiTree T, TElemType c, SqStack2& S)
{
  if(T==NULL)
    return FALSE;
  if(T->data == c)
    return TRUE;
  SElemType tmp;
  tmp.tag = 0;
  if(FindPath(T->lchild, c, S)|| FindPath(T->rchild, c, S))
  {
    tmp.ptr = T;
    Push_Sq2(S, tmp);
  }
  else return FALSE;
  return TRUE;
}

BiTree CommAncestor(BiTree root, TElemType c1, TElemType c2)
{
    if(root == NULL || c1==root->data || c2==root->data) 
      return NULL;       
      
    SqStack2 S1, S2;   
    InitStack_Sq2(S1);  
    InitStack_Sq2(S2);  
    
    if(FindPath(root, c1, S1)==FALSE)
      return NULL;
    if(FindPath(root, c2, S2)==FALSE)
      return NULL;  
    
    SElemType par1, par2, par;
    do{
      par = par1;
      Pop_Sq2(S1, par1);
      Pop_Sq2(S2, par2);
    }while(StackEmpty_Sq2(S1)!=TRUE && StackEmpty_Sq2(S2)!=TRUE && par1.ptr==par2.ptr);
    if(par1.ptr==par2.ptr)
      return par1.ptr;
    else return par.ptr;
}
```
## DC06PE49 编写算法判别给定二叉树是否为完全二叉树
```c
Status CompleteBiTree(BiTree bt)
{  // Add your code here
    if (bt==NULL) {
        return TRUE;
    }

    BiTree p=bt;
    LQueue Q;
    InitQueue_LQ(Q);

    while (p!=NULL) {
        EnQueue_LQ(Q,p->lchild);
        EnQueue_LQ(Q,p->rchild);
        DeQueue_LQ(Q,p);
    }
    while (!QueueEmpty_LQ(Q)) {
        DeQueue_LQ(Q,p);
        if (p!=NULL) {
            if (p->data!=NULL) {
                return FALSE;
            }
        }
    }
    return TRUE;
}
```
## DC06PE50 判别两棵二叉树是否相等
```c
Status  BTEqual(BiTree T1, BiTree T2)
{  // Add your code here
    if (T1==NULL||T2==NULL) {
        if (T1==NULL&&T2==NULL) {
            return TRUE;
        }
        return FALSE;
    }
    if (T1->data==T2->data) {
        return TRUE;
    }else {
        return FALSE;
    }
    Status r1=BTEqual(T1->lchild,T1->lchild);
    Status r2=BTEqual(T1->rchild,T1->rchild);
    return r1&&r2;
}
```
## DC06PE51 求二叉树中度为1的结点数目
```c
void Degree1(BiTree T,int &count)
{  // Add your code here
    if (T==NULL) {
        return;
    }
    if (T->lchild==NULL||T->rchild==NULL) {
        if (!(T->lchild==NULL&&T->rchild==NULL)) {
            count++;
        }
    }
    Degree1(T->lchild,count);
    Degree1(T->rchild,count);
    return;
}
```
## DC06PE52 求二叉树的分支结点总数
```c
int BranchNodes(BiTree T)
{  // Add your code here
    if (T==NULL) {
        return 0;
    }
    if(T->lchild != NULL || T->rchild != NULL){  
        return 1+BranchNodes(T->lchild)+BranchNodes(T->rchild);  
    } 
    return 0;
}
```
## DC06PE53 按层次遍历方式计算二叉树的结点个数
```c
int LevelSum(BiTree T)
{  // Add your code here
    if (T==NULL) {
        return 0;
    }
    return 1+LevelSum(T->lchild)+LevelSum(T->rchild);
}
```
## DC06PE54 对一棵二叉树，将它的所有没有左孩子但有右孩子的结点，将其右孩子改变为左孩子
```c
void ChangeTree(BiTree &T)
{  // Add your code here
    if (T==NULL) {
        return;
    }
    if (T->lchild==NULL && T->rchild!=NULL) {
        T->lchild=T->rchild;
        T->rchild=NULL;
    }
    ChangeTree(T->lchild);
    ChangeTree(T->rchild);
}
```
## DC06PE55 求二叉树的宽度
```c
int BiTreeDepth(BiTree T){
    if (T==NULL) {
        return 0;
    }
    int r1=BiTreeDepth(T->lchild);
    int r2=BiTreeDepth(T->rchild);
    return 1+(r1>r2?r1:r2);
}
int LevelWidth(BiTree T,int level){
    if (T==NULL) {
        return 0;
    }
    if (level==1) {
        return 1;
    }
    return LevelWidth(T->lchild,level-1)+LevelWidth(T->rchild,level-1);
}
int Width(BiTree T)
{  // Add your code here
    if (T==NULL) {
        return 0;
    }
    int maxWid=0,wid;
    int dep=BiTreeDepth(T);
    for (int i = 1; i <= dep+1; i++) {
        wid=LevelWidth(T,i);
        if (wid>maxWid) {
            maxWid=wid;
        }
    }
    return maxWid;
}
```
## DC06PE56 编写递归算法，查找求二叉树T中是否存在元素值为x的结点
```c
Status SearchX(BiTree T, TElemType x)
{  // Add your code here
    if (T==NULL) {
        return FALSE;
    }
    if (T->data==x) {
        return TRUE;
    }
    return SearchX(T->lchild,x)||SearchX(T->rchild,x);
}
```
## DC06PE57 计算二叉树中值为x的结点所在的层次
```c
int NodeLevel(BiTree t, TElemType x)
{  // Add your code here
    if (t==NULL) {
        return -1;
    }
    if (t->data==x) {
        return 1;
    }
    int r1=NodeLevel(t->lchild,x);
    int r2=NodeLevel(t->rchild,x);
    if (r1!=-1||r2!=-1) {
        return (r1>r2)?r1+1:r2+1;
    }
    return -1;
}
```
## DC06PE58 求二叉树中以元素值为x的结点为根的子树的结点总数
```c
void NodeSum(BiTree T,int &count){
    if (T==NULL) {
        return;
    }
    count++;
    NodeSum(T->lchild,count);
    NodeSum(T->rchild,count);
}
int xSum(BiTree T, TElemType x)
{  // Add your code here
    if (T==NULL) {
        return 0;
    }
    if (T->data==x) {
        int count=0;
        NodeSum(T,count);
        return count;
    }
    int r1=xSum(T->lchild,x);
    int r2=xSum(T->rchild,x);
    return r1+r2;
}
```
## DC06PE59 求指定结点在二叉树中的层次
```c
void xLevel(BiTree T,TElemType x, bool &found, int &xlev)
{  // Add your code here
    if (T==NULL||found) {
        return;
    }

    found=FALSE;
    xlev++;
    if (T->data==x) {
        found=TRUE;
        return;
    }
    int temp=xlev;
    xLevel(T->lchild,x,found,xlev);
    if (found==0) {
        xlev=temp;
        xLevel(T->rchild,x,found,xlev);
    }
    else {
        return;
    }
}
```
## DC06PE60 判别一棵二叉树是否为正则二叉树
```c
Status RegularBiTree(BiTree T)
{  // Add your code here
    if (T==NULL) {
        return TRUE;
    }
    if (T->lchild!=NULL||T->rchild!=NULL) {
        if (!(T->lchild!=NULL&&T->rchild!=NULL)) {
            return FALSE;
        }
    }
    return RegularBiTree(T->lchild)&&RegularBiTree(T->rchild);
}
```
## DC06PE61 判别一棵二叉树是否为小根二叉树
```c
bool Small(BiTree T) {
    if (T == NULL) {
        return TRUE;//空树视为小根二叉树
    }
    //检查左子树
    if (T->lchild != NULL && T->data >= T->lchild->data){
        return FALSE;
    }
    //检查右子树
    if (T->rchild != NULL && T->data >= T->rchild->data){
        return FALSE;
    }
    //递归检查左右子树
    return Small(T->lchild) && Small(T->rchild);
}
Status SmallBiTree(BiTree T) {
    if (Small(T)) {
        return SUCCESS;//树是小根二叉树
    }else{
        return ERROR;//树不是小根二叉树
    }
}
```
## DC06PE62 利用队列，非递归求解二叉树的宽度
```c
int Width(BiTree T)
{  // Add your code here
    if (T==NULL) {
        return 0;
    }

    LQueue Q;
    BiTree e;
    InitQueue_LQ(Q);

    int maxWid=-1;
    int lcount=1;
    int count;
    
    EnQueue_LQ(Q,T);
    while (!QueueEmpty_LQ(Q)) {
        count=0;
        for (int i = 0; i < lcount; i++) {
            DeQueue_LQ(Q,e);
            if (e->lchild!=NULL) {
                EnQueue_LQ(Q,e->lchild);
                count++;
            }
            if (e->rchild!=NULL) {
                EnQueue_LQ(Q,e->rchild);
                count++;
            }
        }//层遍历
        if (count>maxWid) {
            maxWid=count;
            lcount=count;
        }
    }
    return maxWid;
}
```
## DC06PE65 试编写一个二叉排序树的判定算法。
```c
Status IsBSTree(BSTree T) 
{   // Add your code here
    if (T==NULL) {
        return TRUE;
    }

    Status r1=TRUE,r2=TRUE;
    if (T->lchild!=NULL) {
        if (T->data.key < T->lchild->data.key) {
            return FALSE;
        }
        r1=IsBSTree(T->lchild);
    }
    if (T->rchild!=NULL) {
        if (T->data.key > T->rchild->data.key) {
            return FALSE;
        }
        r2=IsBSTree(T->rchild);
    }
    return r1&&r2;
}
```
## DC06PE66 从大到小输出给定二叉排序树中所有关键字不小于x的数据元素
```c
void OrderOut(BSTree T, KeyType k, void(*visit)(TElemType))
{   // Add your code here
    if (T==NULL) {
        return;
    }
    
    
    OrderOut(T->rchild,k,visit);
    if (T->data.key>=k) {
        visit(T->data);
    }
    OrderOut(T->lchild,k,visit);
    
}
```
## DC06PE67 在二叉查找树中插入一个元素
```c
Status InsertBST_I(BSTree &T, TElemType k) 
{    // Add your code here
    BSTree pnode = (BSTree)malloc(sizeof(BSTNode));
    pnode->data=k;
    pnode->lchild=pnode->rchild=NULL;

    if (T==NULL) {
        T=pnode;
        return OK;
    }

    BSTree p = T;
    while (1) {//p为指针头，用于负反馈查找pnode应该插入于何处
        if (p->data.key==k.key) {
            return ERROR;
        }//如果相同则报错
        if (p->data.key > k.key) {
            if (p->lchild!=NULL && p->lchild->data.key!=NULL) {
                p=p->lchild;
            }//数值大于节点且右节点已有数值则往左继续查找
            else {
                p->lchild=pnode;
                return OK;
            }
            
        }
        if (p->data.key < k.key) {
            if (p->rchild!=NULL && p->rchild->data.key!=NULL) {
                p=p->rchild;
            }//数值小于节点且左节点已有数值则往右继续查找
            else {
                p->rchild=pnode;
                return OK;
            }

        }
        
    }
}
```
## DC06PE68 求二叉树T中任意两个结点的最近共同祖先。
```c
bool FindPath(BiTree T, TElemType c, Stack& S)
{
  if(T==NULL)
    return FALSE;
  if(T->data == c)
    return TRUE;
  SElemType tmp;
  tmp.tag = 0;
  if(FindPath(T->lchild, c, S)|| FindPath(T->rchild, c, S))
  {
    tmp.ptr = T;
    Push(S, tmp);
  }
  else return FALSE;
  return TRUE;
}

BiTree CommAncestor(BiTree root, TElemType c1, TElemType c2)
{
    if(root == NULL || c1==root->data || c2==root->data) 
      return NULL;       
      
    Stack S1, S2;   
    InitStack(S1);  
    InitStack(S2);  
    
    if(FindPath(root, c1, S1)==FALSE)
      return NULL;
    if(FindPath(root, c2, S2)==FALSE)
      return NULL;  
    
    SElemType par1, par2, par;
    do{
      par = par1;
      Pop(S1, par1);
      Pop(S2, par2);
    }while(StackEmpty(S1)!=TRUE && StackEmpty(S2)!=TRUE && par1.ptr==par2.ptr);
    if(par1.ptr==par2.ptr)
      return par1.ptr;
    else return par.ptr;
}
```
## DC06PE69 将二叉树以字符串形式输出
```c
//参考：https://blog.csdn.net/qq_73060438/article/details/134512751
void BiTreeString(BiTree T,char *str){
    if (T==NULL) {
        strcat(str,"#");
        return;
    }
    strncat(str,&T->data,1);
    if (T->lchild!=NULL||T->rchild!=NULL) {
        strcat(str,"(");
        BiTreeString(T->lchild,str);
        strcat(str,",");
        BiTreeString(T->rchild,str);
        strcat(str,")");
    }
}
char* BiTree2String(BiTree T)
{   // Add your code here
    char * str=(char *)malloc(1000*sizeof(char));
    memset(str, 0, sizeof(char) * 1000);
    BiTreeString(T,str);
    return str;
}
```
## DC06PE75 求二叉排序树中第k小的结点的位置
```c
BSTNode *Ranking(BSTree T, int k) 
{    // Add your code here
    if (T==NULL) {
        return NULL;
    }
    if (T->lsize==k) {
        return T;
    }
    if (T->lsize>k) {
        return Ranking(T->lchild,k);
    }
    if (T->lsize<k) {
        return Ranking(T->rchild,k-T->lsize);
        //减去左子树T->lsize-1包括结点T一共T->lsize个结点
    }
}
```
## DC06PE77 求平衡树T的深度，并j记录每个结点平衡因子
```c
int Depth_BF(BBSTree T) 
{   // Add your code here
    if (T==NULL) {
        return ERROR;
    }
    int r1=Depth_BF(T->lchild);
    int r2=Depth_BF(T->rchild);
    T->bf=r1-r2;
    return 1+(r1>r2?r1:r2);
}
```
## DC06PE82 平衡二叉排序树的右平衡处理
```c
void RightBalance(BBSTree &T) 
{   // Add your code here
    BBSTree rc,ld;
    rc = T->rchild;
    switch (rc->bf) {
    case RH: T->bf = rc->bf = EH; L_Rotate(T); break;
    case LH: 
        ld=rc->lchild;
        switch (ld->bf) {
        case LH: T->bf=EH;rc->bf=RH;break;
        case EH: T->bf=rc->bf=EH;break;
        case RH: T->bf=LH;rc->bf=EH;break;
        }
        ld->bf=EH;
        R_Rotate(T->rchild);
        L_Rotate(T);
    }

}
```
